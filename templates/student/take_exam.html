{% extends "base.html" %}

{% block title %}{{ exam.exam_title }} - {{ app_name }}{% endblock %}

{% set active_page = 'exams' %}
{% block nav_items %}{% include 'components/nav_student.html' %}{% endblock %}
{% block mobile_nav %}{% include 'components/nav_student_mobile.html' %}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/drawing.css') }}">
{% endblock %}

{% block content %}
<!-- Timer Bar -->
<div class="exam-timer-bar" id="timerBar">
    <div class="timer-content">
        <div class="timer-info">
            <span class="timer-subject">{{ exam.subject_name }}</span>
            <span class="timer-title">{{ exam.exam_title }}</span>
        </div>
        <div class="timer-display" id="timerDisplay">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M12 6v6l4 2"/>
            </svg>
            <span id="timerText">--:--</span>
            <span class="timer-label" id="timerLabel">remaining</span>
        </div>
    </div>
    <div class="timer-progress">
        <div class="timer-progress-bar" id="timerProgressBar"></div>
    </div>
</div>

<!-- Exam Header -->
<div class="exam-header">
    <div class="exam-info">
        <h1 class="exam-title">{{ exam.exam_title }}</h1>
        <div class="exam-meta">
            <span class="exam-subject-badge subject-{{ exam.subject_code|lower if exam.subject_code else 'eng' }}">
                {{ exam.subject_name }}
            </span>
            <span class="exam-questions">{{ questions|length }} Questions</span>
            <span class="exam-marks">{{ exam.max_score }} Marks</span>
        </div>
    </div>
    <button type="button" class="btn btn-primary submit-btn" onclick="submitExam()" id="submit-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
        Submit Exam
    </button>
</div>

<!-- Progress Indicator -->
<div class="exam-progress">
    <div class="progress-text">
        <span>Progress: <strong id="answeredCount">0</strong> / {{ questions|length }} answered</span>
    </div>
    <div class="progress">
        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
    </div>
</div>

<!-- Questions -->
<form id="exam-form">
    {% for question in questions %}
    <div class="question-card" data-question-id="{{ question.id }}" id="question-{{ question.id }}">
        <div class="question-header">
            <div class="question-number-badge">Q{{ question.question_number }}</div>
            <div class="question-type-badge">{{ question.question_type|replace('_', ' ')|title }}</div>
            <div class="question-marks-badge">{{ question.marks }} mark{% if question.marks > 1 %}s{% endif %}</div>
        </div>

        <div class="question-body">
            <div class="question-text">
                {% if question.question_html %}
                {{ question.question_html|safe }}
                {% else %}
                {{ question.question_text }}
                {% endif %}
            </div>

            {% if question.image_url %}
            <div class="question-image">
                <img src="{{ question.image_url }}" alt="Question image">
            </div>
            {% endif %}

            <div class="answer-section">
                {% if question.question_type == 'mcq' %}
                <div class="mcq-options">
                    {% for option in question.options %}
                    <label class="mcq-option {% if question.student_answer == option %}selected{% endif %}">
                        <input type="radio" name="q{{ question.id }}" value="{{ option }}"
                               {% if question.student_answer == option %}checked{% endif %}
                               onchange="saveAnswer({{ question.id }}, this.value)">
                        <div class="mcq-radio">
                            <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="6"/></svg>
                        </div>
                        <span class="mcq-text">{{ option }}</span>
                    </label>
                    {% endfor %}
                </div>

                {% elif question.question_type == 'fill_blank' %}
                <div class="fill-blank-wrapper">
                    <input type="text" class="fill-blank-input" name="q{{ question.id }}"
                           value="{{ question.student_answer or '' }}"
                           placeholder="Type your answer here..."
                           onblur="saveAnswer({{ question.id }}, this.value)">
                </div>

                {% elif question.question_type == 'written' %}
                <div class="written-wrapper">
                    <textarea class="written-textarea" name="q{{ question.id }}"
                              placeholder="Write your answer here..."
                              rows="5"
                              onblur="saveAnswer({{ question.id }}, this.value)">{{ question.student_answer or '' }}</textarea>
                    <div class="textarea-hint">Your answer will be reviewed by your teacher</div>
                </div>

                {% elif question.question_type == 'matching' %}
                <div class="matching-wrapper">
                    {% if question.matching_pairs %}
                    <div class="matching-game" data-question-id="{{ question.id }}">
                        <div class="matching-left">
                            {% for pair in question.matching_pairs %}
                            <div class="match-left-item" data-index="{{ loop.index }}">
                                <span class="match-number">{{ loop.index }}</span>
                                <span class="match-text">{{ pair.left }}</span>
                                <div class="match-slot" data-left="{{ loop.index }}">
                                    <span class="slot-placeholder">Drop here</span>
                                </div>
                            </div>
                            {% endfor %}
                        </div>
                        <div class="matching-right">
                            {% for pair in question.matching_pairs %}
                            <div class="match-right-item draggable" draggable="true" data-answer="{{ ['A', 'B', 'C', 'D', 'E', 'F'][loop.index0] }}">
                                <span class="match-letter">{{ ['A', 'B', 'C', 'D', 'E', 'F'][loop.index0] }}</span>
                                <span class="match-text">{{ pair.right }}</span>
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                    {% endif %}
                    <input type="hidden" class="matching-answer" name="q{{ question.id }}"
                           value="{{ question.student_answer or '' }}"
                           onblur="saveAnswer({{ question.id }}, this.value)">
                </div>

                {% elif question.question_type == 'drawing' %}
                <div class="drawing-wrapper">
                    {% if question.drawing_template %}
                    <div class="drawing-instructions">
                        {{ question.drawing_template.instructions if question.drawing_template.instructions else 'Use the drawing tools below to complete your answer.' }}
                    </div>
                    {% endif %}
                    <div class="drawing-container" id="drawing-container-{{ question.id }}"></div>
                    <input type="hidden" name="q{{ question.id }}" id="drawing-data-{{ question.id }}"
                           value="{{ question.student_answer or '' }}">
                    {% if question.drawing_template and question.drawing_template.type == 'flowchart' %}
                    <div class="flowchart-legend">
                        <div class="flowchart-legend-item">
                            <svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
                            <span>Start/End</span>
                        </div>
                        <div class="flowchart-legend-item">
                            <svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="1"/></svg>
                            <span>Process</span>
                        </div>
                        <div class="flowchart-legend-item">
                            <svg viewBox="0 0 24 24"><path d="M12 2l10 10-10 10L2 12z"/></svg>
                            <span>Decision</span>
                        </div>
                        <div class="flowchart-legend-item">
                            <svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                            <span>Arrow/Flow</span>
                        </div>
                    </div>
                    {% endif %}
                </div>

                {% else %}
                <div class="fill-blank-wrapper">
                    <input type="text" class="fill-blank-input" name="q{{ question.id }}"
                           value="{{ question.student_answer or '' }}"
                           placeholder="Type your answer..."
                           onblur="saveAnswer({{ question.id }}, this.value)">
                </div>
                {% endif %}
            </div>

            {% if question.hint %}
            <div class="question-hint">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"/>
                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                </svg>
                <span>{{ question.hint }}</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% endfor %}

    <div class="exam-footer">
        <button type="button" class="btn btn-primary btn-lg" onclick="submitExam()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            Submit Exam
        </button>
    </div>
</form>

<!-- Submit Modal - Revamped -->
<div class="modal-overlay" id="submit-modal">
    <div class="submit-modal">
        <!-- Header with Icon -->
        <div class="submit-modal-header">
            <div class="submit-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
            </div>
            <h2>Ready to Submit?</h2>
            <p>Let's check your work before finishing</p>
        </div>

        <!-- Stats Cards -->
        <div class="submit-modal-body">
            <div class="submit-stats-grid" id="submitStats">
                <!-- Filled by JavaScript -->
            </div>

            <!-- Warning Banner -->
            <div class="submit-warning">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                <span>You can't change answers after submitting!</span>
            </div>

            <!-- Confirm Checkbox -->
            <label class="submit-confirm">
                <input type="checkbox" id="confirmCheck">
                <span class="checkmark"></span>
                <span class="confirm-text">I'm ready to submit my exam</span>
            </label>
        </div>

        <!-- Footer Buttons -->
        <div class="submit-modal-footer">
            <button type="button" class="submit-btn-secondary" onclick="closeModal()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 19l-7-7 7-7m8 14l-7-7 7-7"/>
                </svg>
                Review Answers
            </button>
            <button type="button" class="submit-btn-primary" onclick="confirmSubmit()" id="confirmBtn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 13l4 4L19 7"/>
                </svg>
                Submit Exam
            </button>
        </div>
    </div>
</div>

<style>
/* Timer Bar */
.exam-timer-bar {
    position: sticky;
    top: 48px;
    z-index: 100;
    background: var(--neutral-white);
    border-bottom: 1px solid var(--neutral-gray-6);
    margin: -16px -16px 16px -16px;
    padding: 0;
}
@media (min-width: 768px) {
    .exam-timer-bar {
        margin: -20px -20px 20px -20px;
    }
}
.timer-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
}
.timer-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.timer-subject {
    font-size: 0.75rem;
    color: var(--neutral-gray-50);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.timer-title {
    font-weight: 600;
    color: var(--neutral-gray-80);
    font-size: 0.875rem;
}
.timer-display {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: var(--azure-lighter-blue);
    border-radius: 8px;
    color: var(--azure-blue);
    font-weight: 700;
    font-size: 1.125rem;
    font-variant-numeric: tabular-nums;
}
.timer-display svg {
    width: 20px;
    height: 20px;
}
.timer-label {
    font-size: 0.875rem;
    font-weight: 400;
    opacity: 0.7;
}
.timer-display.warning {
    background: #FFF4CE;
    color: #835C00;
}
.timer-display.danger {
    background: var(--error-bg);
    color: var(--error);
    animation: pulse 1s infinite;
}
.timer-display.delayed {
    background: #FDE7E9;
    color: #C42B1C;
}
.timer-display.delayed::after {
    content: ' (DELAYED)';
    font-size: 0.7rem;
    font-weight: 600;
}
@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}
.timer-progress {
    height: 3px;
    background: var(--neutral-gray-6);
}
.timer-progress-bar {
    height: 100%;
    background: var(--azure-blue);
    transition: width 1s linear;
}

/* Exam Header */
.exam-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 16px;
    margin-bottom: 16px;
    flex-wrap: wrap;
}
.exam-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--neutral-gray-80);
    margin: 0 0 8px 0;
}
.exam-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
}
.exam-subject-badge {
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 600;
}
.exam-questions, .exam-marks {
    font-size: 0.875rem;
    color: var(--neutral-gray-50);
}
.submit-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
}
.submit-btn svg {
    width: 18px;
    height: 18px;
}

/* Progress */
.exam-progress {
    background: var(--neutral-white);
    border: 1px solid var(--neutral-gray-6);
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 16px;
}
.progress-text {
    font-size: 0.875rem;
    color: var(--neutral-gray-50);
    margin-bottom: 8px;
}
.progress-text strong {
    color: var(--azure-blue);
}

/* Question Card */
.question-card {
    background: var(--neutral-white);
    border: 1px solid var(--neutral-gray-6);
    border-radius: 12px;
    margin-bottom: 16px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}
.question-card.answered {
    border-color: var(--success);
    border-width: 2px;
}
.question-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: var(--neutral-gray-2);
    border-bottom: 1px solid var(--neutral-gray-6);
    flex-wrap: wrap;
}
.question-number-badge {
    background: var(--azure-blue);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-weight: 700;
    font-size: 0.875rem;
}
.question-type-badge {
    background: var(--neutral-gray-6);
    color: var(--neutral-gray-60);
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 0.75rem;
    text-transform: uppercase;
}
.question-marks-badge {
    margin-left: auto;
    color: var(--neutral-gray-50);
    font-size: 0.875rem;
    font-weight: 500;
}
.question-body {
    padding: 16px;
}
.question-text {
    font-size: 1rem;
    line-height: 1.6;
    color: var(--neutral-gray-80);
    margin-bottom: 16px;
}
.question-image {
    margin-bottom: 16px;
}
.question-image img {
    max-width: 100%;
    border-radius: 8px;
    border: 1px solid var(--neutral-gray-6);
}

/* MCQ Options */
.mcq-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.mcq-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: var(--neutral-gray-2);
    border: 2px solid var(--neutral-gray-6);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.15s ease;
}
.mcq-option:hover {
    border-color: var(--azure-blue);
    background: var(--azure-lighter-blue);
}
.mcq-option.selected {
    border-color: var(--azure-blue);
    background: var(--azure-lighter-blue);
}
.mcq-option input {
    display: none;
}
.mcq-radio {
    width: 24px;
    height: 24px;
    border: 2px solid var(--neutral-gray-20);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.15s ease;
}
.mcq-radio svg {
    width: 12px;
    height: 12px;
    opacity: 0;
    color: var(--azure-blue);
    transition: opacity 0.15s ease;
}
.mcq-option.selected .mcq-radio {
    border-color: var(--azure-blue);
}
.mcq-option.selected .mcq-radio svg {
    opacity: 1;
}
.mcq-text {
    flex: 1;
    font-size: 0.9375rem;
    color: var(--neutral-gray-80);
}

/* Fill Blank & Written */
.fill-blank-wrapper, .written-wrapper, .matching-wrapper {
    margin-top: 8px;
}
.fill-blank-input {
    width: 100%;
    padding: 12px 16px;
    font-size: 1rem;
    border: 2px solid var(--neutral-gray-20);
    border-radius: 8px;
    background: var(--neutral-white);
    transition: border-color 0.15s ease;
}
.fill-blank-input:focus {
    outline: none;
    border-color: var(--azure-blue);
}
.written-textarea {
    width: 100%;
    padding: 12px 16px;
    font-size: 1rem;
    font-family: inherit;
    border: 2px solid var(--neutral-gray-20);
    border-radius: 8px;
    background: var(--neutral-white);
    resize: vertical;
    min-height: 120px;
    transition: border-color 0.15s ease;
}
.written-textarea:focus {
    outline: none;
    border-color: var(--azure-blue);
}
.textarea-hint, .matching-hint {
    font-size: 0.75rem;
    color: var(--neutral-gray-50);
    margin-top: 8px;
}
.matching-hint {
    margin-bottom: 8px;
    margin-top: 0;
}

/* Matching Game - Drag & Drop */
.matching-game {
    display: flex;
    gap: 20px;
    padding: 20px;
    background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 50%, #a5d6a7 100%);
    border-radius: 16px;
    border: 3px solid #81c784;
    box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
}
.matching-left, .matching-right {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.matching-left {
    padding-right: 10px;
}
.matching-right {
    padding-left: 10px;
    border-left: 2px dashed #81c784;
}
.match-left-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px;
    background: white;
    border-radius: 12px;
    border: 2px solid #e0e0e0;
    box-shadow: 0 3px 8px rgba(0,0,0,0.08);
    transition: all 0.2s;
}
.match-left-item:hover {
    border-color: #64b5f6;
}
.match-number {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #42a5f5, #1976d2);
    color: white;
    border-radius: 50%;
    font-weight: 700;
    font-size: 1rem;
    flex-shrink: 0;
    box-shadow: 0 2px 6px rgba(25, 118, 210, 0.4);
}
.match-left-item .match-text {
    flex: 1;
    font-size: 0.9375rem;
    color: #333;
    font-weight: 500;
}
.match-slot {
    min-width: 60px;
    min-height: 40px;
    padding: 8px 14px;
    background: linear-gradient(135deg, #fff3e0, #ffe0b2);
    border: 3px dashed #ffb74d;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.25s ease;
    flex-shrink: 0;
}
.match-slot.drag-over {
    background: linear-gradient(135deg, #fff8e1, #ffecb3);
    border-color: #ff9800;
    transform: scale(1.08);
    box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
}
.match-slot.filled {
    background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
    border: 3px solid #4caf50;
    border-style: solid;
}
.slot-placeholder {
    color: #ffb74d;
    font-size: 0.75rem;
    font-style: italic;
    font-weight: 500;
}
.match-slot.filled .slot-placeholder {
    display: none;
}
.match-right-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px;
    background: linear-gradient(135deg, #fff, #fafafa);
    border-radius: 12px;
    border: 3px solid #66bb6a;
    cursor: grab;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(102, 187, 106, 0.3);
    user-select: none;
    -webkit-user-select: none;
}
.match-right-item:hover {
    transform: translateY(-3px) scale(1.02);
    box-shadow: 0 6px 20px rgba(102, 187, 106, 0.4);
    border-color: #43a047;
}
.match-right-item:active, .match-right-item.dragging {
    cursor: grabbing;
    opacity: 0.6;
    transform: scale(0.95);
}
.match-right-item.placed {
    opacity: 0.35;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
    border-style: dashed;
    background: #f5f5f5;
}
.match-letter {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #66bb6a, #43a047);
    color: white;
    border-radius: 50%;
    font-weight: 700;
    font-size: 1rem;
    flex-shrink: 0;
    box-shadow: 0 2px 6px rgba(67, 160, 71, 0.4);
}
.match-right-item .match-text {
    flex: 1;
    font-size: 0.9375rem;
    color: #333;
    font-weight: 500;
}
.dropped-answer {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    background: linear-gradient(135deg, #66bb6a, #43a047);
    color: white;
    border-radius: 8px;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(67, 160, 71, 0.4);
    transition: all 0.2s;
}
.dropped-answer:hover {
    background: linear-gradient(135deg, #ef5350, #d32f2f);
    box-shadow: 0 2px 8px rgba(211, 47, 47, 0.4);
    transform: scale(1.05);
}
.dropped-answer::after {
    content: 'Ã—';
    margin-left: 6px;
    font-size: 1.1rem;
    opacity: 0.8;
}
.dropped-answer:hover::after {
    opacity: 1;
}
/* Touch clone styling */
.touch-clone {
    border-radius: 12px;
    background: linear-gradient(135deg, #fff, #e8f5e9);
    border: 3px solid #43a047;
}
@media (max-width: 600px) {
    .matching-game {
        flex-direction: column;
        gap: 16px;
    }
    .matching-right {
        padding-left: 0;
        padding-top: 16px;
        border-left: none;
        border-top: 2px dashed #81c784;
    }
    .match-left-item, .match-right-item {
        padding: 12px;
    }
    .match-slot {
        min-width: 50px;
        min-height: 36px;
    }
}

/* Drawing Wrapper */
.drawing-wrapper {
    margin-top: 8px;
}

/* Question Hint */
.question-hint {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    margin-top: 16px;
    padding: 12px;
    background: #FFF4CE;
    border-radius: 8px;
    font-size: 0.875rem;
    color: #835C00;
}
.question-hint svg {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
}

/* Exam Footer */
.exam-footer {
    text-align: center;
    padding: 24px 0 80px 0;
}
.btn-lg {
    height: 48px;
    padding: 0 32px;
    font-size: 1rem;
    gap: 10px;
}
.btn-lg svg {
    width: 20px;
    height: 20px;
}

/* Submit Stats */
.submit-stats {
    background: var(--neutral-gray-2);
    border-radius: 8px;
    padding: 16px;
    margin-top: 16px;
}
.submit-stats-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid var(--neutral-gray-6);
}
.submit-stats-row:last-child {
    border-bottom: none;
}
.submit-stats-label {
    color: var(--neutral-gray-50);
}
/* ============================================
   SUBMIT MODAL - Revamped Design
   ============================================ */
.submit-modal {
    background: white;
    border-radius: 24px;
    width: 100%;
    max-width: 420px;
    overflow: hidden;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    animation: modalSlideIn 0.3s ease-out;
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.submit-modal-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 28px 24px;
    text-align: center;
}

.submit-icon {
    width: 64px;
    height: 64px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 16px;
}

.submit-icon svg {
    width: 32px;
    height: 32px;
    stroke: white;
}

.submit-modal-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0 0 6px 0;
}

.submit-modal-header p {
    font-size: 0.9rem;
    opacity: 0.9;
    margin: 0;
}

.submit-modal-body {
    padding: 24px;
}

.submit-stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin-bottom: 20px;
}

.submit-stat-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 12px;
    padding: 14px 10px;
    text-align: center;
    border: 1px solid #e9ecef;
}

.submit-stat-card.success {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    border-color: #c3e6cb;
}

.submit-stat-card.warning {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
    border-color: #ffeeba;
}

.submit-stat-card.danger {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    border-color: #f5c6cb;
}

.submit-stat-value {
    font-size: 1.75rem;
    font-weight: 700;
    color: #333;
    line-height: 1;
}

.submit-stat-card.success .submit-stat-value { color: #155724; }
.submit-stat-card.warning .submit-stat-value { color: #856404; }
.submit-stat-card.danger .submit-stat-value { color: #721c24; }

.submit-stat-label {
    font-size: 0.7rem;
    color: #666;
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 500;
}

.submit-warning {
    display: flex;
    align-items: center;
    gap: 12px;
    background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
    border: 1px solid #ffc107;
    border-radius: 12px;
    padding: 14px 16px;
    margin-bottom: 20px;
}

.submit-warning svg {
    width: 24px;
    height: 24px;
    stroke: #856404;
    flex-shrink: 0;
}

.submit-warning span {
    font-size: 0.875rem;
    color: #856404;
    font-weight: 500;
}

.submit-confirm {
    display: flex;
    align-items: center;
    gap: 14px;
    background: linear-gradient(135deg, #e8f4fd 0%, #d4e8f8 100%);
    border: 2px solid #b8daff;
    border-radius: 12px;
    padding: 16px;
    cursor: pointer;
    transition: all 0.2s;
}

.submit-confirm:hover {
    border-color: #667eea;
    background: linear-gradient(135deg, #e0e8ff 0%, #d0d8f8 100%);
}

.submit-confirm input[type="checkbox"] {
    display: none;
}

.submit-confirm .checkmark {
    width: 26px;
    height: 26px;
    border: 2px solid #b8daff;
    border-radius: 8px;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    flex-shrink: 0;
}

.submit-confirm .checkmark::after {
    content: '';
    width: 8px;
    height: 14px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg) scale(0);
    transition: transform 0.2s;
}

.submit-confirm input:checked + .checkmark {
    background: linear-gradient(135deg, #667eea, #764ba2);
    border-color: #667eea;
}

.submit-confirm input:checked + .checkmark::after {
    transform: rotate(45deg) scale(1);
}

.submit-confirm .confirm-text {
    font-size: 0.95rem;
    font-weight: 500;
    color: #333;
}

.submit-modal-footer {
    display: flex;
    gap: 12px;
    padding: 20px 24px 24px;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
}

.submit-btn-secondary,
.submit-btn-primary {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 14px 20px;
    border-radius: 12px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
}

.submit-btn-secondary svg,
.submit-btn-primary svg {
    width: 18px;
    height: 18px;
}

.submit-btn-secondary {
    background: white;
    color: #666;
    border: 2px solid #dee2e6;
}

.submit-btn-secondary:hover {
    background: #f8f9fa;
    border-color: #adb5bd;
    color: #333;
}

.submit-btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
}

.submit-btn-primary:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
}

.submit-btn-primary:disabled {
    background: #dee2e6;
    color: #adb5bd;
    box-shadow: none;
    cursor: not-allowed;
}

@media (max-width: 480px) {
    .submit-modal {
        max-width: 100%;
        margin: 16px;
        border-radius: 20px;
    }

    .submit-modal-header {
        padding: 24px 20px;
    }

    .submit-icon {
        width: 56px;
        height: 56px;
    }

    .submit-icon svg {
        width: 28px;
        height: 28px;
    }

    .submit-modal-header h2 {
        font-size: 1.3rem;
    }

    .submit-stats-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
    }

    .submit-stat-card {
        padding: 12px 8px;
    }

    .submit-stat-value {
        font-size: 1.4rem;
    }

    .submit-modal-footer {
        flex-direction: column;
    }

    .submit-btn-secondary,
    .submit-btn-primary {
        width: 100%;
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/drawing-canvas.js') }}"></script>
<script>
const examId = {{ exam.id }};
const drawingQuestions = {{ questions | selectattr('question_type', 'equalto', 'drawing') | list | tojson }};
const totalQuestions = {{ questions|length }};

// Timer configuration from server
const EXAM_DURATION_MINUTES = {{ exam.duration_minutes or 60 }};
const EXAM_DURATION_SECONDS = EXAM_DURATION_MINUTES * 60;

// Server time sync - calculate remaining seconds
{% if exam.started_at and now %}
const serverElapsedSeconds = {{ (now - exam.started_at).total_seconds()|int }};
const examStartedAt = '{{ exam.started_at }}';
const serverNow = '{{ now }}';
{% else %}
const serverElapsedSeconds = 0;
const examStartedAt = 'not set';
const serverNow = '{{ now }}';
{% endif %}

console.log('Timer Debug:', {
    duration_minutes: EXAM_DURATION_MINUTES,
    duration_seconds: EXAM_DURATION_SECONDS,
    elapsed_seconds: serverElapsedSeconds,
    started_at: examStartedAt,
    server_now: serverNow
});

let remainingSeconds = Math.max(0, EXAM_DURATION_SECONDS - serverElapsedSeconds);
console.log('Remaining seconds:', remainingSeconds);
let timerInterval;
let syncInterval;
let isSubmitting = false;
let examEnded = false;

// Initialize countdown timer
function initTimer() {
    updateTimerDisplay();
    timerInterval = setInterval(updateTimer, 1000);
    // Sync with server every 30 seconds
    syncInterval = setInterval(syncWithServer, 30000);
}

function updateTimer() {
    if (examEnded) return;

    remainingSeconds--;
    updateTimerDisplay();

    // Auto-submit when time runs out
    if (remainingSeconds <= 0 && !isSubmitting) {
        autoSubmitExam();
    }
}

async function syncWithServer() {
    if (examEnded) return;
    try {
        const response = await fetch(`/student/exam/${examId}/time-check`);
        const data = await response.json();
        if (data.remaining_seconds !== undefined) {
            remainingSeconds = Math.max(0, data.remaining_seconds);
            if (remainingSeconds <= 0 && !isSubmitting) {
                autoSubmitExam();
            }
        }
    } catch (e) {
        console.log('Time sync failed, using local timer');
    }
}

function updateTimerDisplay() {
    const display = document.getElementById('timerText');
    const label = document.getElementById('timerLabel');
    const timerDiv = document.getElementById('timerDisplay');
    const progressBar = document.getElementById('timerProgressBar');

    const absRemaining = Math.abs(remainingSeconds);
    const minutes = Math.floor(absRemaining / 60);
    const seconds = absRemaining % 60;

    if (remainingSeconds <= 0) {
        display.textContent = `00:00`;
        label.textContent = 'TIME UP';
    } else {
        display.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        label.textContent = 'remaining';
    }

    // Progress bar shows time remaining (fills as time runs out)
    const usedPercent = Math.min(100, ((EXAM_DURATION_SECONDS - remainingSeconds) / EXAM_DURATION_SECONDS) * 100);
    progressBar.style.width = usedPercent + '%';

    // Status indicators
    timerDiv.classList.remove('warning', 'danger', 'delayed');

    if (remainingSeconds <= 0) {
        timerDiv.classList.add('delayed');
        progressBar.style.background = '#D13438';
    } else if (remainingSeconds <= 300) {
        // 5 minutes or less
        timerDiv.classList.add('danger');
        progressBar.style.background = '#D13438';
    } else if (remainingSeconds <= 600) {
        // 10 minutes or less
        timerDiv.classList.add('warning');
        progressBar.style.background = '#FFB900';
    } else {
        progressBar.style.background = 'var(--azure-blue)';
    }
}

// Auto-submit when time expires
async function autoSubmitExam() {
    if (isSubmitting || examEnded) return;
    isSubmitting = true;
    examEnded = true;

    clearInterval(timerInterval);
    clearInterval(syncInterval);

    // Block UI
    document.getElementById('exam-form').style.pointerEvents = 'none';
    document.getElementById('exam-form').style.opacity = '0.6';

    showToast('Time is up! Auto-submitting your exam...', 'warning');

    // Collect all answers
    const answers = [];
    document.querySelectorAll('.question-card').forEach(card => {
        const qId = card.dataset.questionId;
        let answer = '';

        const radio = card.querySelector('input[type="radio"]:checked');
        const drawingData = card.querySelector('input[id^="drawing-data-"]');

        if (radio) {
            answer = radio.value;
        } else if (drawingData && drawingData.value && drawingData.value.startsWith('data:image')) {
            answer = drawingData.value;
        } else {
            const text = card.querySelector('input[type="text"]:not([type="hidden"]), textarea');
            if (text) answer = text.value.trim();
        }

        answers.push({ question_id: parseInt(qId), answer: answer });
    });

    try {
        const response = await fetch(`/student/exam/${examId}/submit`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers: answers, auto_submit: true })
        });

        const data = await response.json();

        if (data.success) {
            window.removeEventListener('beforeunload', beforeUnloadHandler);
            showToast('Exam auto-submitted successfully!', 'success');
            setTimeout(() => window.location.href = '/student', 2000);
        } else {
            showToast('Auto-submit failed: ' + (data.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        showToast('Auto-submit error. Please contact your teacher.', 'error');
    }
}

// MCQ click handling
document.querySelectorAll('.mcq-option').forEach(option => {
    option.addEventListener('click', function() {
        const parent = this.closest('.mcq-options');
        parent.querySelectorAll('.mcq-option').forEach(o => o.classList.remove('selected'));
        this.classList.add('selected');

        const radio = this.querySelector('input[type="radio"]');
        radio.checked = true;
        saveAnswer(parseInt(this.closest('.question-card').dataset.questionId), radio.value);
        updateProgress();
    });
});

// Auto-save
async function saveAnswer(questionId, answer) {
    try {
        await fetch(`/student/exam/${examId}/save`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question_id: questionId, answer: answer })
        });

        // Mark card as answered
        const card = document.getElementById('question-' + questionId);
        if (answer && answer.trim()) {
            card.classList.add('answered');
        } else {
            card.classList.remove('answered');
        }
        updateProgress();
    } catch (error) {
        console.error('Auto-save failed:', error);
    }
}

// Update progress
function updateProgress() {
    let answered = 0;
    document.querySelectorAll('.question-card').forEach(card => {
        const radio = card.querySelector('input[type="radio"]:checked');
        const text = card.querySelector('input[type="text"]:not([type="hidden"]), textarea');
        const drawingData = card.querySelector('input[id^="drawing-data-"]');

        if (radio || (text && text.value.trim()) || (drawingData && drawingData.value && drawingData.value.startsWith('data:image'))) {
            answered++;
        }
    });

    document.getElementById('answeredCount').textContent = answered;
    document.getElementById('progressBar').style.width = (answered / totalQuestions * 100) + '%';

    return answered;
}

// Submit exam
function submitExam() {
    const answered = updateProgress();
    const unanswered = totalQuestions - answered;
    const percentage = Math.round((answered / totalQuestions) * 100);

    // Determine card states based on values
    const totalClass = '';
    const answeredClass = answered === totalQuestions ? 'success' : (answered > 0 ? 'success' : '');
    const unansweredClass = unanswered > 0 ? (unanswered > totalQuestions / 2 ? 'danger' : 'warning') : 'success';

    let statsHtml = `
        <div class="submit-stat-card">
            <div class="submit-stat-value">${totalQuestions}</div>
            <div class="submit-stat-label">Total</div>
        </div>
        <div class="submit-stat-card ${answeredClass}">
            <div class="submit-stat-value">${answered}</div>
            <div class="submit-stat-label">Answered</div>
        </div>
        <div class="submit-stat-card ${unansweredClass}">
            <div class="submit-stat-value">${unanswered}</div>
            <div class="submit-stat-label">Skipped</div>
        </div>
    `;

    document.getElementById('submitStats').innerHTML = statsHtml;
    document.getElementById('submit-modal').classList.add('active');
}

function closeModal() {
    document.getElementById('submit-modal').classList.remove('active');
    // Reset checkbox and button state
    document.getElementById('confirmCheck').checked = false;
    document.getElementById('confirmBtn').disabled = true;
}

// Enable submit button only when checkbox is checked
document.getElementById('confirmCheck').addEventListener('change', function() {
    document.getElementById('confirmBtn').disabled = !this.checked;
});

async function confirmSubmit() {
    const btn = document.getElementById('confirmBtn');
    btn.disabled = true;
    btn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;animation:spin 1s linear infinite">
            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-4m-2.93-6.07L15.66 7.34M8.34 16.66l-1.41 1.41M16.66 16.66l1.41 1.41M7.34 7.34L5.93 5.93"/>
        </svg>
        Submitting...
    `;

    const answers = [];
    document.querySelectorAll('.question-card').forEach(card => {
        const qId = card.dataset.questionId;
        let answer = '';

        const radio = card.querySelector('input[type="radio"]:checked');
        const drawingData = card.querySelector('input[id^="drawing-data-"]');

        if (radio) {
            answer = radio.value;
        } else if (drawingData && drawingData.value && drawingData.value.startsWith('data:image')) {
            answer = drawingData.value;
        } else {
            const text = card.querySelector('input[type="text"]:not([type="hidden"]), textarea');
            if (text) answer = text.value.trim();
        }

        answers.push({ question_id: parseInt(qId), answer: answer });
    });

    try {
        const response = await fetch(`/student/exam/${examId}/submit`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers: answers })
        });

        const data = await response.json();

        if (data.success) {
            clearInterval(timerInterval);
            window.removeEventListener('beforeunload', beforeUnloadHandler);
            showToast('Exam submitted successfully!', 'success');
            setTimeout(() => window.location.href = '/student', 1500);
        } else {
            showToast(data.error || 'Submission failed', 'error');
            btn.disabled = false;
            btn.textContent = 'Submit';
        }
    } catch (error) {
        showToast('Error submitting exam', 'error');
        btn.disabled = false;
        btn.textContent = 'Submit';
    }

    closeModal();
}

// Warn before leaving
function beforeUnloadHandler(e) {
    e.preventDefault();
    e.returnValue = '';
}
window.addEventListener('beforeunload', beforeUnloadHandler);

// Initialize drawing canvases
const drawingCanvases = {};

function initDrawingCanvases() {
    drawingQuestions.forEach(question => {
        const containerId = `drawing-container-${question.id}`;
        const container = document.getElementById(containerId);

        if (container && typeof DrawingCanvas !== 'undefined') {
            // Get available width
            const availableWidth = container.offsetWidth || window.innerWidth - 60;

            // Responsive canvas sizing based on screen orientation
            let canvasWidth, canvasHeight;

            if (window.innerWidth >= 768) {
                // Desktop/Landscape - wide canvas
                canvasWidth = Math.min(availableWidth, 800);
                canvasHeight = Math.floor(canvasWidth * 0.75); // 4:3 aspect ratio
            } else {
                // Mobile/Portrait - tall canvas
                canvasWidth = Math.min(availableWidth, 500);
                canvasHeight = Math.floor(canvasWidth * 1.4); // Portrait aspect ratio
            }

            // Ensure minimum sizes
            canvasWidth = Math.max(canvasWidth, 320);
            canvasHeight = Math.max(canvasHeight, 450);

            drawingCanvases[question.id] = new DrawingCanvas(containerId, {
                width: canvasWidth,
                height: canvasHeight,
                questionId: question.id,
                type: question.drawing_template?.type || 'freehand',
                onSave: function(qId, imageData) {
                    const hiddenInput = document.getElementById(`drawing-data-${qId}`);
                    if (hiddenInput) {
                        hiddenInput.value = imageData;
                    }
                    saveAnswer(qId, imageData);
                }
            });

            // Load existing drawing if present
            const existingData = document.getElementById(`drawing-data-${question.id}`)?.value;
            if (existingData && existingData.startsWith('data:image')) {
                const canvas = drawingCanvases[question.id];
                if (canvas && canvas.setBackgroundImage) {
                    // Small delay to ensure canvas is ready
                    setTimeout(() => canvas.loadState(existingData), 100);
                }
            }
        }
    });
}

// ============================================
// MATCHING GAME - Drag & Drop
// ============================================
function initMatchingGames() {
    document.querySelectorAll('.matching-game').forEach(game => {
        const questionId = game.dataset.questionId;
        const slots = game.querySelectorAll('.match-slot');
        const draggables = game.querySelectorAll('.match-right-item.draggable');
        const hiddenInput = game.closest('.matching-wrapper').querySelector('.matching-answer');

        // Load existing answer
        if (hiddenInput.value) {
            loadMatchingAnswer(game, hiddenInput.value);
        }

        // Desktop drag events
        draggables.forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
        });

        slots.forEach(slot => {
            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('dragleave', handleDragLeave);
            slot.addEventListener('drop', handleDrop);
        });

        // Touch events for mobile
        draggables.forEach(item => {
            item.addEventListener('touchstart', handleTouchStart, { passive: false });
            item.addEventListener('touchmove', handleTouchMove, { passive: false });
            item.addEventListener('touchend', handleTouchEnd);
        });
    });
}

let draggedItem = null;
let touchClone = null;
let touchStartX = 0;
let touchStartY = 0;

function handleDragStart(e) {
    draggedItem = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', this.dataset.answer);
}

function handleDragEnd(e) {
    this.classList.remove('dragging');
    document.querySelectorAll('.match-slot').forEach(s => s.classList.remove('drag-over'));
    draggedItem = null;
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    if (!this.classList.contains('filled')) {
        this.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    e.preventDefault();
    this.classList.remove('drag-over');

    if (!draggedItem || this.classList.contains('filled')) return;

    const answer = draggedItem.dataset.answer;
    const answerText = draggedItem.querySelector('.match-text').textContent;
    const leftIndex = this.dataset.left;
    const game = this.closest('.matching-game');

    // Place the answer in the slot
    placeAnswer(this, answer, answerText, game, draggedItem);
}

function placeAnswer(slot, answer, answerText, game, sourceItem) {
    // Create dropped answer chip
    const chip = document.createElement('div');
    chip.className = 'dropped-answer';
    chip.dataset.answer = answer;
    chip.innerHTML = `<span class="chip-letter">${answer}</span>`;
    chip.title = 'Click to remove';

    // Click to remove
    chip.addEventListener('click', () => {
        removeAnswer(slot, answer, game, sourceItem);
    });

    // Clear slot and add chip
    slot.innerHTML = '';
    slot.appendChild(chip);
    slot.classList.add('filled');

    // Mark source as placed
    if (sourceItem) {
        sourceItem.classList.add('placed');
        sourceItem.draggable = false;
    }

    // Update hidden input and save
    updateMatchingAnswer(game);
}

function removeAnswer(slot, answer, game, sourceItem) {
    // Restore slot
    slot.innerHTML = '<span class="slot-placeholder">Drop here</span>';
    slot.classList.remove('filled');

    // Find and restore the draggable
    const draggable = game.querySelector(`.match-right-item[data-answer="${answer}"]`);
    if (draggable) {
        draggable.classList.remove('placed');
        draggable.draggable = true;
    }

    // Update hidden input
    updateMatchingAnswer(game);
}

function updateMatchingAnswer(game) {
    const slots = game.querySelectorAll('.match-slot');
    const pairs = [];

    slots.forEach(slot => {
        const leftIndex = slot.dataset.left;
        const chip = slot.querySelector('.dropped-answer');
        if (chip) {
            pairs.push(`${leftIndex}-${chip.dataset.answer}`);
        }
    });

    const answer = pairs.join(',');
    const wrapper = game.closest('.matching-wrapper');
    const hiddenInput = wrapper.querySelector('.matching-answer');
    const questionId = game.dataset.questionId;

    hiddenInput.value = answer;
    saveAnswer(parseInt(questionId), answer);

    // Mark question as answered if all slots filled
    const card = game.closest('.question-card');
    if (pairs.length === slots.length) {
        card.classList.add('answered');
    } else {
        card.classList.remove('answered');
    }
    updateProgress();
}

function loadMatchingAnswer(game, answerStr) {
    if (!answerStr) return;

    // Parse "1-A,2-B,3-C" format
    const pairs = answerStr.split(',');

    pairs.forEach(pair => {
        const [leftIndex, answer] = pair.split('-');
        if (!leftIndex || !answer) return;

        const slot = game.querySelector(`.match-slot[data-left="${leftIndex}"]`);
        const draggable = game.querySelector(`.match-right-item[data-answer="${answer}"]`);

        if (slot && draggable) {
            const answerText = draggable.querySelector('.match-text').textContent;
            placeAnswer(slot, answer, answerText, game, draggable);
        }
    });
}

// ============================================
// TOUCH SUPPORT FOR MATCHING
// ============================================
function handleTouchStart(e) {
    if (this.classList.contains('placed')) return;

    e.preventDefault();
    draggedItem = this;

    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;

    // Create visual clone for dragging
    touchClone = this.cloneNode(true);
    touchClone.classList.add('touch-clone');
    touchClone.style.cssText = `
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        opacity: 0.9;
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        left: ${touch.clientX - this.offsetWidth / 2}px;
        top: ${touch.clientY - this.offsetHeight / 2}px;
    `;
    document.body.appendChild(touchClone);

    this.classList.add('dragging');
}

function handleTouchMove(e) {
    if (!draggedItem || !touchClone) return;
    e.preventDefault();

    const touch = e.touches[0];

    // Move clone
    touchClone.style.left = `${touch.clientX - draggedItem.offsetWidth / 2}px`;
    touchClone.style.top = `${touch.clientY - draggedItem.offsetHeight / 2}px`;

    // Find slot under touch
    const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const slot = elemBelow?.closest('.match-slot');

    // Clear all drag-over states
    document.querySelectorAll('.match-slot').forEach(s => s.classList.remove('drag-over'));

    // Highlight current slot
    if (slot && !slot.classList.contains('filled')) {
        slot.classList.add('drag-over');
    }
}

function handleTouchEnd(e) {
    if (!draggedItem) return;

    // Find slot under last touch position
    const touch = e.changedTouches[0];
    const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const slot = elemBelow?.closest('.match-slot');

    if (slot && !slot.classList.contains('filled')) {
        const answer = draggedItem.dataset.answer;
        const answerText = draggedItem.querySelector('.match-text').textContent;
        const game = slot.closest('.matching-game');

        placeAnswer(slot, answer, answerText, game, draggedItem);
    }

    // Clean up
    draggedItem.classList.remove('dragging');
    document.querySelectorAll('.match-slot').forEach(s => s.classList.remove('drag-over'));

    if (touchClone) {
        touchClone.remove();
        touchClone = null;
    }

    draggedItem = null;
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initTimer();
    updateProgress();

    // Initialize drawing canvases
    initDrawingCanvases();

    // Initialize matching games
    initMatchingGames();

    // Add blur handlers for text inputs
    document.querySelectorAll('.fill-blank-input, .written-textarea').forEach(input => {
        input.addEventListener('blur', function() {
            const card = this.closest('.question-card');
            const qId = card.dataset.questionId;
            saveAnswer(parseInt(qId), this.value);
        });
    });
});
</script>
{% endblock %}
